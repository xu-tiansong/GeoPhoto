<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Photo Viewer</title>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="node_modules/leaflet/dist/leaflet.css" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            user-select: none;
        }

        /* ── Title Bar ─────────────────────────────────── */
        .title-bar {
            -webkit-app-region: drag;
            height: 40px;
            background: rgba(0,0,0,0.45);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 14px;
            border-bottom: 1px solid #2e2e2e;
            flex-shrink: 0;
        }
        .title-bar-text { font-size: 14px; font-weight: 500; color: #ddd; }
        .title-bar-close {
            -webkit-app-region: no-drag;
            width: 30px; height: 30px;
            background: #c62828;
            border: none; border-radius: 4px;
            cursor: pointer; color: #fff; font-size: 18px; line-height: 1;
            display: flex; align-items: center; justify-content: center;
            transition: background 0.15s;
        }
        .title-bar-close:hover { background: #b71c1c; }

        /* ── Main Layout ───────────────────────────────── */
        .main { flex: 1; display: flex; overflow: hidden; }

        /* 左侧照片容器 */
        .photo-container {
            flex: 1;
            background: #0a0a0a;
            position: relative;
            overflow: hidden;
            cursor: grab;
        }

        .photo-container.dragging {
            cursor: grabbing;
        }

        .photo-wrapper {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .photo-wrapper img,
        .photo-wrapper video {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            user-select: none;
            -webkit-user-drag: none;
            transition: transform 0.1s ease-out;
        }

        .photo-wrapper video {
            display: none;
            width: 100%;
            height: 100%;
        }

        .photo-wrapper video.active {
            display: block;
        }

        .photo-wrapper img.active {
            display: block;
        }

        .photo-wrapper img:not(.active) {
            display: none;
        }

        /* 翻页导航箭头 */
        .nav-arrow {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 48px;
            height: 96px;
            background: rgba(0, 0, 0, 0.28);
            color: rgba(255, 255, 255, 0.75);
            font-size: 36px;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border-radius: 6px;
            z-index: 20;
            transition: background 0.18s, color 0.18s;
            user-select: none;
            -webkit-app-region: no-drag;
        }

        .nav-arrow:hover {
            background: rgba(0, 0, 0, 0.72);
            color: #fff;
        }

        .nav-arrow.visible {
            display: flex;
        }

        .nav-prev { left: 12px; }
        .nav-next { right: 12px; }

        /* 缩放控制按钮 */
        .zoom-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            border-radius: 6px;
            z-index: 10;
        }

        .zoom-btn {
            background: #2a2a2a;
            border: 1px solid #383838;
            color: #e0e0e0;
            width: 30px;
            height: 30px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.15s;
        }

        .zoom-btn:hover {
            background: #333;
        }

        .zoom-level {
            color: #aaa;
            display: flex;
            align-items: center;
            padding: 0 10px;
            font-size: 14px;
        }

        /* 右侧容器 */
        .sidebar {
            width: 320px;
            background: #2a2a2a;
            display: flex;
            flex-direction: column;
        }

        /* Tab导航 */
        .tab-nav {
            display: flex;
            background: #1a1a1a;
            padding: 10px 10px 0 10px;
            gap: 5px;
        }

        .tab-btn {
            flex: 1;
            padding: 10px;
            background: transparent;
            border: none;
            color: #666;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.18s;
            font-size: 12px;
            font-family: inherit;
        }

        .tab-btn:hover {
            color: #bbb;
            background: rgba(255,255,255,0.04);
        }

        .tab-btn.active {
            color: #e0e0e0;
            border-bottom-color: #4a9eff;
        }

        /* Tab内容 */
        .tab-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .tab-pane {
            display: none;
        }

        .tab-pane.active {
            display: block;
        }

        /* Info面板样式 */
        .info-row {
            margin-bottom: 16px;
        }

        .info-label {
            color: #777;
            font-size: 11px;
            margin-bottom: 4px;
        }

        .info-value {
            color: #e0e0e0;
            font-size: 14px;
            word-break: break-all;
        }

        /* Remark输入框样式 */
        .remark-container {
            margin-top: 16px;
        }

        .remark-textarea {
            width: 100%;
            min-height: 80px;
            background: #222;
            border: 1px solid #383838;
            border-radius: 4px;
            color: #ddd;
            padding: 8px;
            font-size: 13px;
            font-family: inherit;
            resize: vertical;
            outline: none;
            transition: border-color 0.15s;
        }

        .remark-textarea:focus {
            border-color: #4a9eff;
        }

        .remark-save-btn {
            margin-top: 8px;
            padding: 6px 16px;
            background: #4a9eff;
            border: none;
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
            font-size: 13px;
            font-family: inherit;
            transition: background 0.15s;
            display: none;
        }

        .remark-save-btn.visible {
            display: inline-block;
        }

        .remark-save-btn:hover {
            background: #3a8eef;
        }

        /* Like按钮 */
        .like-container {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid #2e2e2e;
        }

        .like-btn {
            width: 100%;
            padding: 10px;
            background: #2a2a2a;
            border: 1px solid #383838;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            color: #777;
            font-size: 13px;
            font-family: inherit;
            transition: all 0.15s;
        }

        .like-btn:hover {
            background: #333;
            color: #ff6b6b;
        }

        .like-btn.liked {
            background: #ff6b6b;
            color: #fff;
        }

        .like-btn.liked:hover {
            background: #ff5252;
        }

        .like-btn .heart-icon {
            font-size: 18px;
        }

        /* Similar Photos面板 */
        .similar-photos-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .similar-photo-item {
            aspect-ratio: 1;
            background: #1a1a1a;
            border-radius: 4px;
            cursor: pointer;
            overflow: hidden;
            transition: transform 0.2s;
        }

        .similar-photo-item:hover {
            transform: scale(1.05);
        }

        .similar-photo-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* Tags面板 */
        .tags-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .tag-pill {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: #2a2a2a;
            border: 1px solid #383838;
            padding: 4px 8px 4px 10px;
            border-radius: 16px;
            font-size: 12px;
            color: #e0e0e0;
        }
        .tag-pill .tag-dot {
            width: 6px; height: 6px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        .tag-pill .tag-remove {
            width: 16px; height: 16px;
            background: transparent;
            border: none;
            color: #666;
            cursor: pointer;
            font-size: 14px;
            line-height: 1;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }
        .tag-pill .tag-remove:hover {
            color: #ff5252;
            background: rgba(255,82,82,0.15);
        }

        .tag-btn-row {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }
        .add-tag-btn, .match-tag-btn {
            background: #4a9eff;
            border: none;
            padding: 6px 16px;
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
            font-size: 13px;
            font-family: inherit;
            transition: background 0.15s;
        }
        .match-tag-btn {
            background: #4caf50;
        }
        .match-tag-btn:hover { background: #43a047; }
        .match-tag-btn:disabled { opacity: 0.6; cursor: not-allowed; }

        .add-tag-btn:hover {
            background: #3a8eef;
        }

        /* 小地图样式 */
        .mini-map-container {
            margin-top: 16px;
            border-radius: 4px;
            overflow: hidden;
            background: #1a1a1a;
        }

        .mini-map-label {
            color: #777;
            font-size: 11px;
            margin-bottom: 8px;
        }

        #miniMap {
            width: 100%;
            height: 180px;
            border-radius: 4px;
        }

        /* 占位符文本 */
        .placeholder {
            color: #666;
            text-align: center;
            padding: 40px 20px;
        }

        /* 滚动条样式 */
        .tab-content::-webkit-scrollbar { width: 5px; }
        .tab-content::-webkit-scrollbar-track { background: transparent; }
        .tab-content::-webkit-scrollbar-thumb { background: #3a3a3a; border-radius: 3px; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@vladmandic/face-api@1/dist/face-api.js"></script>
</head>
<body>
    <!-- 顶部标题栏 -->
    <div class="title-bar">
        <div class="title-bar-text" data-i18n="photo.title">Photo</div>
        <button class="title-bar-close" id="closeBtn">×</button>
    </div>

    <div class="main">
    <!-- 左侧照片容器 -->
    <div class="photo-container" id="photoContainer">
        <!-- 翻页导航箭头 -->
        <div class="nav-arrow nav-prev" id="navPrev">&#8249;</div>
        <div class="nav-arrow nav-next" id="navNext">&#8250;</div>
        <div class="photo-wrapper" id="photoWrapper">
            <img id="photoImage" src="" alt="Photo" class="active">
            <video id="videoPlayer" controls preload="metadata">
                Your browser does not support the video tag.
            </video>
        </div>
        <div class="zoom-controls">
            <button class="zoom-btn" id="zoomOut" data-i18n-title="photo.zoomOut" title="Zoom Out">−</button>
            <span class="zoom-level" id="zoomLevel">100%</span>
            <button class="zoom-btn" id="zoomIn" data-i18n-title="photo.zoomIn" title="Zoom In">+</button>
            <button class="zoom-btn" id="zoomReset" data-i18n-title="photo.reset" title="Reset">⟲</button>
        </div>
    </div>

    <!-- 右侧容器 -->
    <div class="sidebar">
        <!-- Tab导航 -->
        <div class="tab-nav">
            <button class="tab-btn active" data-tab="info" data-i18n="photo.tabInfo">Info</button>
            <button class="tab-btn" data-tab="similar" data-i18n="photo.tabSimilar">Similar</button>
            <button class="tab-btn" data-tab="tags" data-i18n="photo.tabTags">Tags</button>
        </div>

        <!-- Tab内容 -->
        <div class="tab-content">
            <!-- Info面板 -->
            <div class="tab-pane active" id="tab-info">
                <div class="info-row">
                    <div class="info-label" data-i18n="photo.filename">Filename</div>
                    <div class="info-value" id="info-filename">-</div>
                </div>
                <div class="info-row">
                    <div class="info-label" data-i18n="photo.directory">Directory</div>
                    <div class="info-value" id="info-directory">-</div>
                </div>
                <div class="info-row">
                    <div class="info-label" data-i18n="photo.datetime">Date & Time</div>
                    <div class="info-value" id="info-datetime">-</div>
                </div>
                <div class="info-row">
                    <div class="info-label" data-i18n="photo.location">Location</div>
                    <div class="info-value" id="info-location">-</div>
                </div>
                <div class="info-row">
                    <div class="info-label" data-i18n="photo.coordinates">Coordinates</div>
                    <div class="info-value" id="info-coordinates">-</div>
                </div>
                <div class="mini-map-container" id="miniMapContainer" style="display: none;">
                    <div class="mini-map-label" data-i18n="photo.mapLocation">Map Location</div>
                    <div id="miniMap"></div>
                </div>
                <div class="remark-container">
                    <div class="info-label" data-i18n="photo.remark">Remark</div>
                    <textarea class="remark-textarea" id="remark-textarea" data-i18n-placeholder="photo.remarkPlaceholder" placeholder="Add your notes here..."></textarea>
                    <button class="remark-save-btn" id="remark-save-btn" data-i18n="photo.save">Save</button>
                </div>
                <div class="like-container">
                    <button class="like-btn" id="likeBtn">
                        <span class="heart-icon">♥</span>
                        <span class="like-text" data-i18n="photo.like">Like this photo</span>
                    </button>
                </div>
            </div>

            <!-- Similar面板 -->
            <div class="tab-pane" id="tab-similar">
                <div class="placeholder" data-i18n="photo.comingSoon">Coming soon...</div>
            </div>

            <!-- Tags面板 -->
            <div class="tab-pane" id="tab-tags">
                <div class="tags-container" id="tags-container">
                    <!-- Tags will be added here -->
                </div>
                <div class="tag-btn-row">
                    <button class="add-tag-btn" data-i18n="photo.addTag">Add Tag</button>
                    <button class="match-tag-btn" data-i18n="photo.matchTag">Match Tags</button>
                </div>
            </div>
        </div>
    </div>
    </div><!-- /.main -->

    <script>
        const { ipcRenderer } = require('electron');
        const L = require('leaflet');
        const { pathToFileURL } = require('url');
        const i18n = require('./modules/i18n');

        // i18n 初始化
        (async () => {
            const lang = await ipcRenderer.invoke('get-language');
            i18n.applyToDOM(document, lang);
        })();
        ipcRenderer.on('language-changed', (_event, lang) => {
            i18n.applyToDOM(document, lang);
        });

        let currentPhoto = null;
        let navTotal = 0;
        let navCurrentIndex = -1;
        let scale = 1;
        let translateX = 0;
        let translateY = 0;
        let isDragging = false;
        let startX = 0;
        let startY = 0;
        let miniMap = null;
        let miniMapMarker = null;
        let originalRemark = '';

        const photoContainer = document.getElementById('photoContainer');
        const photoWrapper = document.getElementById('photoWrapper');
        const photoImage = document.getElementById('photoImage');
        const videoPlayer = document.getElementById('videoPlayer');
        const zoomLevel = document.getElementById('zoomLevel');

        // 加载照片数据
        ipcRenderer.on('load-photo', (event, photoData) => {
            currentPhoto = photoData;
            loadPhoto(photoData);
        });

        // 翻页导航信息
        ipcRenderer.on('set-navigation', (event, { currentIndex, total }) => {
            navCurrentIndex = currentIndex;
            navTotal = total;
            const prevArrow = document.getElementById('navPrev');
            const nextArrow = document.getElementById('navNext');
            prevArrow.classList.toggle('visible', currentIndex > 0);
            nextArrow.classList.toggle('visible', currentIndex < total - 1);
        });

        // 翻页箭头点击
        document.getElementById('navPrev').addEventListener('click', async (e) => {
            e.stopPropagation();
            await ipcRenderer.invoke('navigate-photo', 'prev');
        });

        document.getElementById('navNext').addEventListener('click', async (e) => {
            e.stopPropagation();
            await ipcRenderer.invoke('navigate-photo', 'next');
        });

        // 加载照片
        async function loadPhoto(photo) {
            // 使用fullPath如果存在，否则拼接路径
            const filePath = photo.fullPath || 
                (photo.directory.includes(photo.filename) 
                    ? photo.directory 
                    : `${photo.directory}\\${photo.filename}`);
            
            // 转换为标准 file URL
            const fileUrl = pathToFileURL(filePath).href;
            
            console.log('Loading media:', {
                type: photo.type,
                filename: photo.filename,
                directory: photo.directory,
                filePath: filePath,
                fileUrl: fileUrl
            });
            
            // 根据类型显示图片或视频
            if (photo.type === 'video') {
                photoImage.classList.remove('active');
                videoPlayer.classList.add('active');
                
                // 直接设置视频src
                videoPlayer.src = fileUrl;
                
                // 添加错误处理
                videoPlayer.onerror = (e) => {
                    console.error('Video error:', e);
                    console.error('Video error details:', {
                        error: videoPlayer.error,
                        networkState: videoPlayer.networkState,
                        readyState: videoPlayer.readyState,
                        src: videoPlayer.src
                    });
                };
                
                // 等待视频元数据加载后再重置缩放
                videoPlayer.onloadedmetadata = () => {
                    console.log('Video metadata loaded:', {
                        width: videoPlayer.videoWidth,
                        height: videoPlayer.videoHeight,
                        duration: videoPlayer.duration
                    });
                    resetZoom();
                };
                
                // 视频全屏事件处理
                videoPlayer.addEventListener('enterpictureinpicture', () => {
                    console.log('Entered picture-in-picture');
                });
                
                videoPlayer.load();
            } else {
                videoPlayer.classList.remove('active');
                photoImage.classList.add('active');
                photoImage.src = fileUrl;
                
                // 等待图片加载完成后再重置缩放
                photoImage.onload = () => {
                    resetZoom();
                };
                
                // 如果图片已经缓存加载完成
                if (photoImage.complete && photoImage.naturalWidth > 0) {
                    resetZoom();
                }
            }
            
            // 更新Info信息
            document.getElementById('info-filename').textContent = photo.filename || '-';
            document.getElementById('info-directory').textContent = photo.directory || '-';
            document.getElementById('info-datetime').textContent = photo.time ? new Date(photo.time).toLocaleString() : '-';
            
            if (photo.lat && photo.lng) {
                document.getElementById('info-coordinates').textContent = `${photo.lat.toFixed(6)}, ${photo.lng.toFixed(6)}`;
                document.getElementById('info-location').textContent = i18n.t('photo.loading');

                // 显示地图容器
                document.getElementById('miniMapContainer').style.display = 'block';

                // 初始化小地图
                initMiniMap(photo.lat, photo.lng);

                // 异步获取城市名称
                try {
                    const cityName = await ipcRenderer.invoke('get-city-name', { lat: photo.lat, lng: photo.lng });
                    document.getElementById('info-location').textContent = cityName;
                } catch (error) {
                    console.error('Failed to get city name:', error);
                    document.getElementById('info-location').textContent = i18n.t('photo.failedLoad');
                }
            } else {
                document.getElementById('info-coordinates').textContent = '-';
                document.getElementById('info-location').textContent = i18n.t('photo.noLocation');
                // 隐藏地图容器
                document.getElementById('miniMapContainer').style.display = 'none';
            }

            // 加载remark
            const remarkTextarea = document.getElementById('remark-textarea');
            remarkTextarea.value = photo.remark || '';
            originalRemark = photo.remark || '';
            document.getElementById('remark-save-btn').classList.remove('visible');

            // 加载Like状态
            const likeBtn = document.getElementById('likeBtn');
            const likeText = likeBtn.querySelector('.like-text');
            if (photo.like) {
                likeBtn.classList.add('liked');
                likeText.textContent = i18n.t('photo.liked');
            } else {
                likeBtn.classList.remove('liked');
                likeText.textContent = i18n.t('photo.like');
            }

            // 加载标签
            if (photo.id) loadPhotoTags(photo.id);
        }

        // 缩放控制
        document.getElementById('zoomIn').addEventListener('click', () => {
            scale = Math.min(scale + 0.25, 5);
            updateTransform();
        });

        document.getElementById('zoomOut').addEventListener('click', () => {
            const minScale = getMinScale();
            scale = Math.max(scale - 0.25, minScale);
            updateTransform();
        });

        document.getElementById('zoomReset').addEventListener('click', () => {
            resetZoom();
        });

        // 鼠标滚轮缩放 - 在body上捕获所有wheel事件
        document.body.addEventListener('wheel', function(e) {
            // 检查鼠标是否在照片容器区域
            const rect = photoContainer.getBoundingClientRect();
            
            if (e.clientX >= rect.left && e.clientX <= rect.right && 
                e.clientY >= rect.top && e.clientY <= rect.bottom) {
                e.preventDefault();
                e.stopImmediatePropagation();
                const delta = e.deltaY > 0 ? -0.1 : 0.1;
                const minScale = getMinScale();
                const newScale = scale + delta;
                scale = Math.max(minScale, Math.min(5, newScale));
                updateTransform();
            }
        }, { passive: false, capture: true });

        // 拖动功能
        photoContainer.addEventListener('mousedown', (e) => {
            // 检查是否需要拖动（媒体超出容器）
            const containerWidth = photoContainer.clientWidth;
            const containerHeight = photoContainer.clientHeight;
            
            let imageWidth, imageHeight;
            if (videoPlayer.classList.contains('active')) {
                imageWidth = videoPlayer.videoWidth || containerWidth;
                imageHeight = videoPlayer.videoHeight || containerHeight;
            } else {
                imageWidth = photoImage.naturalWidth || containerWidth;
                imageHeight = photoImage.naturalHeight || containerHeight;
            }
            
            // 计算实际显示尺寸
            const containerAspect = containerWidth / containerHeight;
            const imageAspect = imageWidth / imageHeight;
            let displayWidth, displayHeight;
            
            if (imageAspect > containerAspect) {
                displayWidth = Math.min(imageWidth, containerWidth);
                displayHeight = displayWidth / imageAspect;
            } else {
                displayHeight = Math.min(imageHeight, containerHeight);
                displayWidth = displayHeight * imageAspect;
            }
            
            const scaledWidth = displayWidth * scale;
            const scaledHeight = displayHeight * scale;
            
            // 如果缩放后的尺寸超出容器，允许拖动
            if (scaledWidth > containerWidth || scaledHeight > containerHeight) {
                isDragging = true;
                startX = e.clientX - translateX;
                startY = e.clientY - translateY;
                photoContainer.classList.add('dragging');
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                translateX = e.clientX - startX;
                translateY = e.clientY - startY;
                constrainTranslation();
                updateTransform();
            }
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
            photoContainer.classList.remove('dragging');
        });

        // 限制平移范围，防止露出背景
        function constrainTranslation() {
            // 获取容器尺寸
            const containerWidth = photoContainer.clientWidth;
            const containerHeight = photoContainer.clientHeight;

            // 获取媒体实际显示尺寸（自然尺寸）
            let imageWidth, imageHeight;
            if (videoPlayer.classList.contains('active')) {
                imageWidth = videoPlayer.videoWidth || containerWidth;
                imageHeight = videoPlayer.videoHeight || containerHeight;
            } else {
                imageWidth = photoImage.naturalWidth;
                imageHeight = photoImage.naturalHeight;
            }

            // 计算照片在容器中的实际渲染尺寸（考虑max-width/max-height）
            let displayWidth = imageWidth;
            let displayHeight = imageHeight;
            
            // 模拟CSS的contain行为
            const containerAspect = containerWidth / containerHeight;
            const imageAspect = imageWidth / imageHeight;
            
            if (imageAspect > containerAspect) {
                // 图片更宽，以宽度为准
                displayWidth = Math.min(imageWidth, containerWidth);
                displayHeight = displayWidth / imageAspect;
            } else {
                // 图片更高，以高度为准
                displayHeight = Math.min(imageHeight, containerHeight);
                displayWidth = displayHeight * imageAspect;
            }

            // 计算缩放后的尺寸
            const scaledWidth = displayWidth * scale;
            const scaledHeight = displayHeight * scale;

            // 计算最大允许的偏移量（缩放后的图片边缘不能超出容器）
            const maxTranslateX = Math.max(0, (scaledWidth - containerWidth) / 2);
            const maxTranslateY = Math.max(0, (scaledHeight - containerHeight) / 2);

            // 限制平移范围
            translateX = Math.max(-maxTranslateX, Math.min(maxTranslateX, translateX));
            translateY = Math.max(-maxTranslateY, Math.min(maxTranslateY, translateY));
        }

        // 更新变换
        function updateTransform() {
            constrainTranslation();
            const transformValue = `scale(${scale}) translate(${translateX / scale}px, ${translateY / scale}px)`;
            
            // 确保正确的元素被应用transform
            const activeElement = videoPlayer.classList.contains('active') ? videoPlayer : photoImage;
            activeElement.style.transform = transformValue;
            
            zoomLevel.textContent = `${Math.round(scale * 100)}%`;
        }

        // 重置缩放
        function resetZoom() {
            scale = 1;
            translateX = 0;
            translateY = 0;
            updateTransform();
        }

        // 计算最小缩放值（确保至少一边等于容器）
        function getMinScale() {
            const containerWidth = photoContainer.clientWidth;
            const containerHeight = photoContainer.clientHeight;
            
            let imageWidth, imageHeight;
            if (videoPlayer.classList.contains('active')) {
                imageWidth = videoPlayer.videoWidth || containerWidth;
                imageHeight = videoPlayer.videoHeight || containerHeight;
            } else {
                imageWidth = photoImage.naturalWidth || containerWidth;
                imageHeight = photoImage.naturalHeight || containerHeight;
            }
            
            if (!imageWidth || !imageHeight) {
                return 1; // 默认最小值
            }
            
            // 计算contain模式下的显示尺寸
            const containerAspect = containerWidth / containerHeight;
            const imageAspect = imageWidth / imageHeight;
            
            let displayWidth, displayHeight;
            if (imageAspect > containerAspect) {
                // 图片更宽，以容器宽度为准
                displayWidth = containerWidth;
                displayHeight = containerWidth / imageAspect;
            } else {
                // 图片更高，以容器高度为准
                displayHeight = containerHeight;
                displayWidth = containerHeight * imageAspect;
            }
            
            // 在scale=1时，图片已经以contain方式适配
            // 最小scale就是1，不允许缩小，这样至少一边始终填满容器
            return 1;
        }

        // 初始化小地图
        function initMiniMap(lat, lng) {
            // 如果地图已存在，先移除
            if (miniMap) {
                miniMap.remove();
                miniMap = null;
                miniMapMarker = null;
            }

            // 等待DOM元素准备好
            setTimeout(() => {
                // 创建小地图
                miniMap = L.map('miniMap', {
                    center: [lat, lng],
                    zoom: 13,
                    zoomControl: false,
                    attributionControl: false,
                    dragging: false,
                    scrollWheelZoom: true,
                    doubleClickZoom: false,
                    touchZoom: false
                });

                // 添加地图图层
                L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                    attribution: ''
                }).addTo(miniMap);

                // 添加标签图层
                L.tileLayer('https://{s}.basemaps.cartocdn.com/light_only_labels/{z}/{x}/{y}{r}.png', {
                    attribution: '',
                    subdomains: 'abcd'
                }).addTo(miniMap);

                // 添加标记
                miniMapMarker = L.marker([lat, lng]).addTo(miniMap);

                // 缩放时保持标记在中心
                miniMap.on('zoomend', function() {
                    miniMap.setView([lat, lng]);
                });

                // 调整地图大小
                setTimeout(() => {
                    miniMap.invalidateSize();
                }, 100);
            }, 50);
        }

        // Tab切换
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const tabName = btn.dataset.tab;
                
                // 更新按钮状态
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                // 更新内容显示
                document.querySelectorAll('.tab-pane').forEach(pane => pane.classList.remove('active'));
                document.getElementById(`tab-${tabName}`).classList.add('active');
                
                // 切换到Info tab时刷新地图
                if (tabName === 'info' && miniMap) {
                    setTimeout(() => {
                        miniMap.invalidateSize();
                    }, 50);
                }
            });
        });

        // Remark输入变化监听
        const remarkTextarea = document.getElementById('remark-textarea');
        const remarkSaveBtn = document.getElementById('remark-save-btn');

        remarkTextarea.addEventListener('input', () => {
            const currentValue = remarkTextarea.value;
            if (currentValue !== originalRemark) {
                remarkSaveBtn.classList.add('visible');
            } else {
                remarkSaveBtn.classList.remove('visible');
            }
        });

        // Remark保存按钮
        remarkSaveBtn.addEventListener('click', async () => {
            const remarkValue = remarkTextarea.value;
            
            if (!currentPhoto) return;
            
            try {
                // 调用IPC保存remark
                await ipcRenderer.invoke('save-photo-remark', {
                    directory: currentPhoto.directory,
                    filename: currentPhoto.filename,
                    remark: remarkValue
                });
                
                // 更新原始值和隐藏按钮
                originalRemark = remarkValue;
                remarkSaveBtn.classList.remove('visible');
                
                // 更新currentPhoto对象
                currentPhoto.remark = remarkValue;
                
                console.log('Remark saved successfully');
            } catch (error) {
                console.error('Failed to save remark:', error);
                alert(i18n.t('photo.failedSave'));
            }
        });

        // 关闭按钮
        document.getElementById('closeBtn').addEventListener('click', () => {
            window.close();
        });

        // Like按钮
        document.getElementById('likeBtn').addEventListener('click', async () => {
            if (!currentPhoto) return;
            
            const likeBtn = document.getElementById('likeBtn');
            const likeText = likeBtn.querySelector('.like-text');
            const newLikeState = !currentPhoto.like;
            
            try {
                const result = await ipcRenderer.invoke('toggle-photo-like', {
                    directory: currentPhoto.directory,
                    filename: currentPhoto.filename,
                    like: newLikeState
                });
                
                if (result.success) {
                    currentPhoto.like = newLikeState;
                    if (newLikeState) {
                        likeBtn.classList.add('liked');
                        likeText.textContent = i18n.t('photo.liked');
                    } else {
                        likeBtn.classList.remove('liked');
                        likeText.textContent = i18n.t('photo.like');
                    }
                }
            } catch (error) {
                console.error('Failed to toggle like:', error);
            }
        });

        // 视频全屏处理
        document.addEventListener('fullscreenchange', () => {
            if (document.fullscreenElement === videoPlayer) {
                // 进入全屏，通知主进程将窗口全屏
                ipcRenderer.invoke('set-photo-window-fullscreen', true);
            } else if (!document.fullscreenElement) {
                // 退出全屏，恢复窗口
                ipcRenderer.invoke('set-photo-window-fullscreen', false);
            }
        });

        // ESC键关闭
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                window.close();
            }
        });

        // ── Tag Management ───────────────────────────────────
        async function loadPhotoTags(photoId) {
            const container = document.getElementById('tags-container');
            container.innerHTML = '';
            try {
                const res = await ipcRenderer.invoke('get-photo-tags', { photoId });
                if (res.success && res.tags.length > 0) {
                    res.tags.forEach(tag => container.appendChild(createTagPill(tag, photoId)));
                }
            } catch (e) {
                console.error('Failed to load tags:', e);
            }
        }

        function createTagPill(tag, photoId) {
            const pill = document.createElement('div');
            pill.className = 'tag-pill';
            pill.dataset.tagId = tag.id;
            pill.style.borderColor = tag.color || '#383838';

            const dot = document.createElement('span');
            dot.className = 'tag-dot';
            dot.style.backgroundColor = tag.color || '#3498db';
            pill.appendChild(dot);

            const name = document.createElement('span');
            name.textContent = tag.name;
            pill.appendChild(name);

            const removeBtn = document.createElement('button');
            removeBtn.className = 'tag-remove';
            removeBtn.textContent = '\u00d7';
            removeBtn.addEventListener('click', async () => {
                const res = await ipcRenderer.invoke('unlink-tag-from-photo', { photoId, tagId: tag.id });
                if (res.success) pill.remove();
            });
            pill.appendChild(removeBtn);

            return pill;
        }

        document.querySelector('.add-tag-btn').addEventListener('click', async () => {
            if (!currentPhoto || !currentPhoto.id) return;
            await ipcRenderer.invoke('open-tag-select-window', { photoId: currentPhoto.id });
        });

        ipcRenderer.on('tag-added', async (_event, tagInfo) => {
            if (!currentPhoto) return;
            const container = document.getElementById('tags-container');
            if (container.querySelector(`[data-tag-id="${tagInfo.tagId}"]`)) return;
            container.appendChild(createTagPill({
                id: tagInfo.tagId,
                name: tagInfo.tagName,
                color: tagInfo.tagColor
            }, currentPhoto.id));

            // 若是地标 tag 且成功为无位置照片补充了坐标，则刷新位置显示
            if (tagInfo.locationApplied) {
                const { lat, lng } = tagInfo.locationApplied;
                currentPhoto.lat = lat;
                currentPhoto.lng = lng;
                document.getElementById('info-coordinates').textContent = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
                document.getElementById('info-location').textContent = i18n.t('photo.loading');
                document.getElementById('miniMapContainer').style.display = 'block';
                initMiniMap(lat, lng);
                try {
                    const cityName = await ipcRenderer.invoke('get-city-name', { lat, lng });
                    document.getElementById('info-location').textContent = cityName;
                } catch (_) {
                    document.getElementById('info-location').textContent = i18n.t('photo.failedLoad');
                }
            }
        });

        // ── Match Tags ───────────────────────────────────
        let faceApiLoaded = false;

        async function ensureFaceApiLoaded() {
            if (faceApiLoaded) return true;
            if (typeof faceapi === 'undefined') return false;
            try {
                const MODEL_URL = 'https://cdn.jsdelivr.net/npm/@vladmandic/face-api@1/model';
                await Promise.all([
                    faceapi.nets.ssdMobilenetv1.loadFromUri(MODEL_URL),
                    faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL),
                    faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL),
                ]);
                faceApiLoaded = true;
                return true;
            } catch (err) {
                console.error('face-api model load error:', err);
                return false;
            }
        }

        function euclideanDistance(a, b) {
            let sum = 0;
            for (let i = 0; i < a.length; i++) {
                const d = a[i] - b[i];
                sum += d * d;
            }
            return Math.sqrt(sum);
        }

        document.querySelector('.match-tag-btn').addEventListener('click', async () => {
            if (!currentPhoto || !currentPhoto.id) return;

            const btn = document.querySelector('.match-tag-btn');
            const originalText = btn.textContent;
            btn.disabled = true;
            btn.textContent = i18n.t('photo.matching');

            try {
                let matchedFaceTagIds = [];

                // Rule 1: Face matching (in renderer process)
                if (currentPhoto.type !== 'video') {
                    const loaded = await ensureFaceApiLoaded();
                    if (loaded) {
                        try {
                            const img = document.getElementById('photoImage');
                            // Create a canvas for detection (resize large images)
                            const maxDim = 800;
                            let canvas = document.createElement('canvas');
                            const scale = Math.min(1, maxDim / Math.max(img.naturalWidth, img.naturalHeight));
                            canvas.width = img.naturalWidth * scale;
                            canvas.height = img.naturalHeight * scale;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                            const detections = await faceapi
                                .detectAllFaces(canvas)
                                .withFaceLandmarks()
                                .withFaceDescriptors();

                            if (detections.length > 0) {
                                // Get all face tags with descriptors
                                const faceRes = await ipcRenderer.invoke('get-all-face-descriptors');
                                if (faceRes.success && faceRes.faceTags.length > 0) {
                                    const THRESHOLD = 0.6;
                                    const matchedIds = new Set();

                                    for (const det of detections) {
                                        const photoDesc = Array.from(det.descriptor);
                                        let bestMatch = null;
                                        let bestDist = Infinity;

                                        for (const faceTag of faceRes.faceTags) {
                                            for (const sample of faceTag.descriptors) {
                                                const dist = euclideanDistance(photoDesc, sample.descriptor);
                                                if (dist < bestDist) {
                                                    bestDist = dist;
                                                    bestMatch = faceTag;
                                                }
                                            }
                                        }

                                        if (bestMatch && bestDist < THRESHOLD) {
                                            matchedIds.add(bestMatch.id);
                                        }
                                    }

                                    matchedFaceTagIds = Array.from(matchedIds);
                                }
                            }
                        } catch (faceErr) {
                            console.error('Face matching error:', faceErr);
                        }
                    }
                }

                // Rules 2 & 3: Event + Location matching (in main process)
                const res = await ipcRenderer.invoke('match-tags-for-photo', {
                    photoId: currentPhoto.id,
                    matchedFaceTagIds
                });

                if (res.success && res.matchedTags.length > 0) {
                    const container = document.getElementById('tags-container');
                    for (const tag of res.matchedTags) {
                        if (!container.querySelector(`[data-tag-id="${tag.id}"]`)) {
                            container.appendChild(createTagPill(tag, currentPhoto.id));
                        }
                    }
                    btn.textContent = i18n.t('photo.matchResult', { count: res.matchedTags.length });
                } else {
                    btn.textContent = i18n.t('photo.matchNone');
                }

                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.disabled = false;
                }, 2000);

            } catch (err) {
                console.error('Match tags error:', err);
                btn.textContent = originalText;
                btn.disabled = false;
            }
        });
    </script>
</body>
</html>
